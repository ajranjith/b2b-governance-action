/**
 * Path Service - Handles PATH updates and config file management
 */

const { execSync, spawn } = require("child_process");
const fs = require("fs");
const path = require("path");
const os = require("os");

const INSTALL_DIR = path.join(os.homedir(), "AppData", "Local", "Programs", "gres-b2b");
const CONFIG_DIR = path.join(os.homedir(), "AppData", "Local", "gres-b2b");
const CONFIG_NAME = "config.toml";

/**
 * Get the install path
 */
function getInstallPath() {
  return {
    installDir: INSTALL_DIR,
    configDir: CONFIG_DIR,
    configPath: path.join(CONFIG_DIR, CONFIG_NAME),
    binaryPath: path.join(INSTALL_DIR, "gres-b2b.exe"),
  };
}

/**
 * Add install directory to user PATH via registry
 * Uses PowerShell for reliable registry access
 */
async function applyPath() {
  try {
    // Get current user PATH
    const getCurrentPath = `
      $p = [Environment]::GetEnvironmentVariable('Path', 'User')
      if ($p) { $p } else { '' }
    `;
    const currentPath = execSync(`powershell -NoProfile -Command "${getCurrentPath}"`, {
      windowsHide: true,
      encoding: "utf8",
    }).trim();

    // Check if already in PATH
    const pathParts = currentPath.split(";").map((p) => p.trim().toLowerCase());
    const installDirLower = INSTALL_DIR.toLowerCase();

    if (pathParts.some((p) => p === installDirLower || p === installDirLower + "\\")) {
      return {
        success: true,
        message: "Install directory already in PATH",
        alreadyInPath: true,
      };
    }

    // Add to PATH
    const newPath = currentPath ? `${INSTALL_DIR};${currentPath}` : INSTALL_DIR;
    const setPathCmd = `
      [Environment]::SetEnvironmentVariable('Path', '${newPath.replace(/'/g, "''")}', 'User')
    `;
    execSync(`powershell -NoProfile -Command "${setPathCmd}"`, {
      windowsHide: true,
    });

    // Broadcast WM_SETTINGCHANGE
    broadcastEnvChange();

    return {
      success: true,
      message: "Added to PATH successfully",
      path: INSTALL_DIR,
    };
  } catch (err) {
    return {
      success: false,
      error: `Failed to update PATH: ${err.message}`,
    };
  }
}

/**
 * Broadcast WM_SETTINGCHANGE so new processes pick up PATH changes
 */
function broadcastEnvChange() {
  try {
    // Use PowerShell to broadcast the message
    const broadcastCmd = `
      Add-Type -TypeDefinition @"
        using System;
        using System.Runtime.InteropServices;
        public class EnvBroadcast {
          [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
          public static extern IntPtr SendMessageTimeout(
            IntPtr hWnd, uint Msg, UIntPtr wParam, string lParam,
            uint fuFlags, uint uTimeout, out UIntPtr lpdwResult);
          public static void Broadcast() {
            UIntPtr result;
            SendMessageTimeout((IntPtr)0xFFFF, 0x001A, UIntPtr.Zero, "Environment",
              0x0002, 2000, out result);
          }
        }
"@
      [EnvBroadcast]::Broadcast()
    `;
    execSync(`powershell -NoProfile -Command "${broadcastCmd}"`, {
      windowsHide: true,
    });
  } catch (e) {
    // Non-fatal, continue anyway
    console.error("Failed to broadcast env change:", e.message);
  }
}

/**
 * Write TOML config file
 */
async function writeConfig(opts = {}) {
  try {
    const { agent, projectPath, version } = opts;

    // Create config directory
    fs.mkdirSync(CONFIG_DIR, { recursive: true });

    const configPath = path.join(CONFIG_DIR, CONFIG_NAME);
    const timestamp = new Date().toISOString();

    const content = `# GRES B2B Governance Configuration
# Generated by installer at ${timestamp}

[agent]
name = "${agent || "Claude Desktop"}"
mcp_enabled = true

[project]
root = "${(projectPath || "").replace(/\\/g, "/")}"

[governance]
auto_scan = true

[install]
version = "${version || "1.0.0"}"
binary_path = "${path.join(INSTALL_DIR, "gres-b2b.exe").replace(/\\/g, "/")}"
`;

    fs.writeFileSync(configPath, content, "utf8");

    return {
      success: true,
      path: configPath,
      message: "Config file created",
    };
  } catch (err) {
    return {
      success: false,
      error: `Failed to write config: ${err.message}`,
    };
  }
}

module.exports = {
  applyPath,
  writeConfig,
  getInstallPath,
  broadcastEnvChange,
  INSTALL_DIR,
  CONFIG_DIR,
};
